## 垃圾回收

**V8如何回收老生代对象**

垃圾回收会阻塞程序的执行，v8的标记增量方式垃圾回收和执行是交替执行的

* 主要是采用标记清除、标记整理、增量标记算法
* 主要使用标记清除完成垃圾空间的回收
* 采用标记整理进行空间优化（新生晋级时候，老年代不够，进行标记整理，获得更大的空间）
* 采用增量标记进行效率优化

1. 新生代区域垃圾回收使用空间换时间，使用的复制算法，因为本身小，浪费的空间很小
2. 老生代区域一分为二，浪费空间很大，存放数据较多，复制时间较多，不适合使用复制算法

**v8总结**

* 



### 为啥使用Performance

* GC的目的是为了实现内存空间的良性循环

通过performance时刻监控内存

performance是Chrome开发的性能工具，其他浏览器也可以使用

希望在写代码的过程中时刻了解程序运行时候整个内存的变化，从而发现一些内存的问题，辅助我们在代码中作出一些变化，提高运行的效率

### 内存问题的外在表现

* 页面出现延迟加载或经常性暂停（GC存在频繁的垃圾回收，定位代码）
* 页面持续性出现糟糕的性能，客户感知到不好用，慢（存在内存膨胀，指当前界面为了达到最佳使用速度，可能会申请一定的内存大小，这个内存超过了设置可提供的内存）
* 页面的性能随时间延长越来越差（存在内存泄露，刚开始没问题，某些问题代码的出现，内存越来越少）

界定内存问题的标准

* 内存泄露：内存使用持续升高（持续升高，中间没有下降）
* 内存膨胀：在多数设备上都存在性能问题（使用多个设备测试，性能有问题的占比多）
* 频繁垃圾回收：通过内存变化图可以观察

监控内存的几种方式

* 浏览器任务管理器
* timeline时序图记录
* 堆快照查找分离DOM（分离DOM也是内存上的泄露）
* 判断是否存在频繁的垃圾回收

任务管理器监控内存（判断问题）

创建一个html

按钮绑定点击事件

点击创建一个非常长的数组

* 内存，表示原生内存，DOM节点所占用内存的变化
* js内存，主要关注小括号内的数值，小括号内的数值一直增加，没有变小，表示内存有问题，可能泄露

Timeline记录内存（定位问题节点）

通过时间线记录内存变化

创建dom节点

绑定点击事件

创建大量节点，通过数组方法，生成大的字符串



什么是分离DOM

* 界面元素存活在DOM树上
* 垃圾对象时的DOM节点
* 分离状态的DOM节点（界面元素脱离了DOM树，但是代码中有人在引用，称为分离状态的DOM节点）

创建元素绑定点击事件，执行创建dom节点，赋值，但不添加到body中

确定是否频繁垃圾回收

* Timeline中频繁的上升下降
* 任务管理器中数据频繁的增加减小

用户感知卡顿

### Jsperf使用流程

* 登录
* 填写个人信息（非必须）
* 测试用例信息（title，slug）slug是唯一的
* 准备代码
* 必要有setup和teardown代码
* 测试代码片段

**慎用全局变量**

* 查找时间消耗较多
* 对于当前GC工作是不利的，降低程序运行过程中对内存的使用
* 使用全局变量和局部变量两者性能差异

**缓存全局变量**

将使用中无法避免的全局变量缓存到局部

**在原型对象上添加方法**

提高代码执行效率

**避开闭包陷阱**

* 闭包使用不当很容易出现内存泄露
* 闭包，在外部作用域可以访问到内部作用域的变量
* 外部对内部有引用
* 当前函数在调用时候存在一个新的作用域

把事件函数

**避免属性访问方法使用**

可以直接访问

**For循环优化**

提前获取length

```js

```

**采用最优循环方式**

for in

forEach

for



**节点添加优化**

节点的添加必然会造成回流和重绘

使用文档碎片进行优化

```js
document.createDocumentFragment() //文档碎片
```

**克隆优化节点操作**

在文档中添加大量节点时候，可以先复制



### 性能优化2

**堆栈中JS的执行过程**

